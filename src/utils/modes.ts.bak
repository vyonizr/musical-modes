const KEYS = {
  'letter': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
  'roman': ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii']
}

const KEYS2 = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B']

const ROMAN_NUMERAL_MODES = {
  'Ionian': ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'],
  'Dorian': ['i', 'ii', '♭III', 'IV', 'v', 'vi°', '♭VII'],
  'Phrygian': ['i', '♭II', '♭III', 'iv', 'v°', '♭VI', '♭vii'],
  'Lydian': ['I', 'II', 'iii', '♯iv°', 'V', 'vi', 'vii'],
  'Mixolydian': ['I', 'ii', 'iii°', 'IV', 'v', 'vi', '♭VII'],
  'Aeolian': ['i', 'ii°', '♭III', 'iv', 'v', '♭VI', '♭VII'],
  'Locrian': ['i°', '♭II', '♭iii', 'iv', '♭V', '♭VI', '♭vii']
}

const IONIAN_INTERVALS = ['W', 'W', 'H', 'W', 'W', 'W', 'H']

const INTERVALS = {
  'Ionian': IONIAN_INTERVALS,
  'Dorian': IONIAN_INTERVALS,
  'Phrygian': ['H', 'W', 'W', 'W', 'H', 'W', 'W'],
  'Lydian': ['W', 'W', 'W', 'H', 'W', 'W', 'H'],
  'Mixolydian': ['W', 'W', 'H', 'W', 'W', 'H', 'W'],
  'Aeolian': ['W', 'H', 'flat major', 'minor', 'minor', 'flat major', 'flat major'],
  'Locrian': ['H', 'flat major', 'flat minor', 'minor', 'flat major', 'flat major', 'flat minor']
}

const ROMAN_NUMERAL_MODES_PROPERTIES = {
  'Ionian': ['major', 'minor', 'minor', 'major', 'major', 'minor', 'diminished'],
  'Dorian': ['minor', 'minor', 'flat major', 'major', 'minor', 'diminished', 'flat major'],
  'Phrygian': ['minor', 'flat major', 'flat major', 'minor', 'diminished', 'flat major', 'flat minor'],
  'Lydian': ['major', 'major', 'minor', 'sharp diminished', 'major', 'minor', 'minor'],
  'Mixolydian': ['major', 'minor', 'diminished', 'major', 'minor', 'minor', 'flat major'],
  'Aeolian': ['minor', 'diminished', 'flat major', 'minor', 'minor', 'flat major', 'flat major'],
  'Locrian': ['diminished', 'flat major', 'flat minor', 'minor', 'flat major', 'flat major', 'flat minor']
}

const generateKeysAndNumerals = (scale = 'C', mode = 'Ionian') => {
  const usedMode = ROMAN_NUMERAL_MODES_PROPERTIES[mode]
  const generated = {
    letter: [],
    roman: []
  }
  for (let i = 0; i < usedMode.length; i++) {
    let splitProperty = usedMode[i].split(' ')

    generated.letter.push(parserKey(splitProperty, i, shifter(scale)))
    generated.roman.push(parserNumeral(splitProperty, i))
  }

  return generated
}

const shifter = (scale: string, letterKeys = KEYS['letter']) => {
  const scaleIndex = letterKeys.findIndex(key => key === scale)

  return [...letterKeys.slice(scaleIndex), ...letterKeys.slice(0, scaleIndex)]
}

const sharpOrFlat = (property: string[]): string => {
  let result = ''
  if(property.some((chordType: string) => chordType === 'flat')) {
    result += '♭'
  }
  else if(property.some((chordType: string) => chordType === 'sharp')) {
    result += '♯'
  }
  return result
}

const diminished = (property: string[]): string => {
  if(property.some(chord => chord === 'diminished')) {
    return '°'
  }
  return ''
}

const parserKey = (property = [], index: number, letterKeys = KEYS['letter']) => {
  let result = letterKeys[index]

  result += sharpOrFlat(property)

  if (property.some(chord => chord === 'minor')) {
    result += 'm'
  }

  result += diminished(property)

  return result
}

const parserNumeral = (property: string[], index: number, romanKeys = KEYS['roman'], ) => {
  let result = ''

  result += sharpOrFlat(property)

  if (property.some((chord: string) => chord === 'major')) {
    result += romanKeys[index].toUpperCase()
  }
  else {
    result += romanKeys[index]
  }

  result += diminished(property)

  return result
}

export {}